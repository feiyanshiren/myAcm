面试题 16.05. 阶乘尾数
设计一个算法，算出 n 阶乘有多少个尾随零。

示例 1:

输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
示例 2:

输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
说明: 你算法的时间复杂度应为 O(log n) 。

解：

使用库函数超时

```py
import math

class Solution:
    def trailingZeroes(self, n: int) -> int:
        s  = str(math.factorial(n))
        r = 0
        for i in range(len(s) - 1, -1, -1):
            if s[i] == "0":
                r += 1
            else:
                break
        return r
```
---


面试题 16.05. 阶乘尾数    --2
设计一个算法，算出 n 阶乘有多少个尾随零。

示例 1:

输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
示例 2:

输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
说明: 你算法的时间复杂度应为 O(log n) 。

解：

整除5的累加 90+ 效率好
这题数5的原因，是因为只有 质数 5*2=10，

阶乘里，2的数量远大于5，只要是偶数都是2的倍数，所以直接数阶乘里 总共有几个5即可
```py
class Solution:
    def trailingZeroes(self, n: int) -> int:
        z = n // 5
        r = z
        while z != 0:
            z //= 5
            r += z
        return r
```
---


面试题 16.05. 阶乘尾数    --3
设计一个算法，算出 n 阶乘有多少个尾随零。

示例 1:

输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
示例 2:

输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
说明: 你算法的时间复杂度应为 O(log n) 。

解：go 100

这题数5的原因，是因为只有 质数 5*2=10，

阶乘里，2的数量远大于5，只要是偶数都是2的倍数，所以直接数阶乘里 总共有几个5即可；

但因为25和其倍数，如25*2.。。。里面都有两个5，所以遇到25和倍数都要+2；

同理125和其倍数，里面有3个5，所以遇到125和其倍数要+3；

因为25是5的倍数，125是25的倍数，

也就是说25，125的倍数都和5的倍数是重叠的；

所以从n/5开始，然后+n/25，+n/125，依次类推，这样就等于进行叠加了，不用额外考虑什么情况+2，什么情况+3...的问题；
```go
func trailingZeroes(n int) int {
    return n/1220703125+n/244140625+n/48828125+n/9765625+n/1953125+n/390625+n/78125+n/15625+n/3125+n/625+n/125+n/25+n/5
}
```
---
