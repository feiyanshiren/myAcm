剑指 Offer 60. n个骰子的点数
把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。

 

你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。

 

示例 1:

输入: 1
输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
示例 2:

输入: 2
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
 

限制：

1 <= n <= 11

解：
打表, 效率高， 先吧答案套出来
```py
class Solution:
    def twoSum(self, n: int) -> List[float]:
        m = dict()
        m[1] = [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
        m[2] = [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
        m[3] = [0.00463,0.01389,0.02778,0.04630,0.06944,0.09722,0.11574,0.12500,0.12500,0.11574,0.09722,0.06944,0.04630,0.02778,0.01389,0.00463]
        m[4] = [0.00077,0.00309,0.00772,0.01543,0.02701,0.04321,0.06173,0.08025,0.09645,0.10802,0.11265,0.10802,0.09645,0.08025,0.06173,0.04321,0.02701,0.01543,0.00772,0.00309,0.00077]
        m[5] = [0.00013,0.00064,0.00193,0.00450,0.00900,0.01620,0.02636,0.03922,0.05401,0.06944,0.08372,0.09452,0.10031,0.10031,0.09452,0.08372,0.06944,0.05401,0.03922,0.02636,0.01620,0.00900,0.00450,0.00193,0.00064,0.00013]
        m[6] = [0.00002,0.00013,0.00045,0.00120,0.00270,0.00540,0.00977,0.01620,0.02488,0.03571,0.04816,0.06121,0.07354,0.08372,0.09047,0.09285,0.09047,0.08372,0.07354,0.06121,0.04816,0.03571,0.02488,0.01620,0.00977,0.00540,0.00270,0.00120,0.00045,0.00013,0.00002]
        m[7] = [0.00000,0.00003,0.00010,0.00030,0.00075,0.00165,0.00328,0.00595,0.01003,0.01578,0.02336,0.03266,0.04328,0.05454,0.06547,0.07499,0.08204,0.08579,0.08579,0.08204,0.07499,0.06547,0.05454,0.04328,0.03266,0.02336,0.01578,0.01003,0.00595,0.00328,0.00165,0.00075,0.00030,0.00010,0.00003,0.00000]
        m[8] = [0.00000,0.00000,0.00002,0.00007,0.00020,0.00047,0.00102,0.00201,0.00366,0.00624,0.01001,0.01517,0.02184,0.02994,0.03918,0.04905,0.05883,0.06769,0.07477,0.07936,0.08094,0.07936,0.07477,0.06769,0.05883,0.04905,0.03918,0.02994,0.02184,0.01517,0.01001,0.00624,0.00366,0.00201,0.00102,0.00047,0.00020,0.00007,0.00002,0.00000,0.00000]
        m[9] = [0.00000,0.00000,0.00000,0.00002,0.00005,0.00013,0.00030,0.00063,0.00124,0.00226,0.00390,0.00635,0.00982,0.01448,0.02040,0.02753,0.03567,0.04442,0.05324,0.06148,0.06844,0.07349,0.07615,0.07615,0.07349,0.06844,0.06148,0.05324,0.04442,0.03567,0.02753,0.02040,0.01448,0.00982,0.00635,0.00390,0.00226,0.00124,0.00063,0.00030,0.00013,0.00005,0.00002,0.00000,0.00000,0.00000]
        m[10] = [0.00000,0.00000,0.00000,0.00000,0.00001,0.00003,0.00008,0.00019,0.00039,0.00077,0.00141,0.00245,0.00403,0.00634,0.00954,0.01375,0.01904,0.02539,0.03262,0.04046,0.04846,0.05612,0.06287,0.06816,0.07153,0.07269,0.07153,0.06816,0.06287,0.05612,0.04846,0.04046,0.03262,0.02539,0.01904,0.01375,0.00954,0.00634,0.00403,0.00245,0.00141,0.00077,0.00039,0.00019,0.00008,0.00003,0.00001,0.00000,0.00000,0.00000,0.00000]
        m[11] = [0.00000,0.00000,0.00000,0.00000,0.00000,0.00001,0.00002,0.00005,0.00012,0.00025,0.00048,0.00088,0.00154,0.00257,0.00409,0.00625,0.00919,0.01301,0.01778,0.02347,0.02995,0.03702,0.04432,0.05145,0.05793,0.06331,0.06715,0.06916,0.06916,0.06715,0.06331,0.05793,0.05145,0.04432,0.03702,0.02995,0.02347,0.01778,0.01301,0.00919,0.00625,0.00409,0.00257,0.00154,0.00088,0.00048,0.00025,0.00012,0.00005,0.00002,0.00001,0.00000,0.00000,0.00000,0.00000,0.00000]
        return m[n]
```
---



剑指 Offer 60. n个骰子的点数    --2
把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。

 

你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。

 

示例 1:

输入: 1
输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
示例 2:

输入: 2
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
 

限制：

1 <= n <= 11

解：
解题思路
题目需要我们求出所有点数出现的概率，根据概率的计算公式，点数 kk 出现概率就算公式为：

P_{(k)} = k出现的次数 / 总次数
P 
(k)
​	
 =k出现的次数/总次数

投掷 nn 个骰子，所有点数出现的总次数是 6^n6 
n
  ，因为一共有 nn 枚骰子，每枚骰子的点数都有 66 种可能出现的情况。

我们的目的就是 计算出投掷完 nn 枚骰子后每个点数出现的次数。

使用递归造成的重复计算问题
感谢 @bakezq 对此部分提出了更容易理解的讲解方式。

单纯使用递归搜索解空间的时间复杂度为 6^n6 
n
  ，会造成超时错误，因为存在重复子结构。解释如下：

我们使用递归函数 getCount(n, k)getCount(n,k) 来表示投掷 nn 枚骰子，点数 kk 出现的次数。

为了简化分析，我们以投掷 22 枚骰子为例。

我们来模拟计算点数 44 和 点数 66 ，这两种点数各自出现的次数。也就是计算 getCount(2, 4)getCount(2,4) 和 getCount(2, 6)getCount(2,6)。

它们的计算公式为：

getCount(2, 4) = getCount(1, 1) + getCount(1, 2) + getCount(1, 3)
getCount(2,4)=getCount(1,1)+getCount(1,2)+getCount(1,3)

getCount(2, 6) = getCount(1, 1) + getCount(1, 2) + getCount(1, 3) + getCount(1, 4) + getCount(1, 5)
getCount(2,6)=getCount(1,1)+getCount(1,2)+getCount(1,3)+getCount(1,4)+getCount(1,5)

我们发现递归统计这两种点数的出现次数时，重复计算了

getCount(1, 1) , getCount(1, 2) , getCount(1, 3)
getCount(1,1),getCount(1,2),getCount(1,3)

这些子结构，计算其它点数的次数时同样存在大量的重复计算。

动态规划
使用动态规划解决问题一般分为三步：

表示状态
找出状态转移方程
边界处理
下面我们一步一步分析，相信你一定会有所收获！

表示状态
分析问题的状态时，不要分析整体，只分析最后一个阶段即可！因为动态规划问题都是划分为多个阶段的，各个阶段的状态表示都是一样，而我们的最终答案在就是在最后一个阶段。

对于这道题，最后一个阶段是什么呢？

通过题目我们知道一共投掷 nn 枚骰子，那最后一个阶段很显然就是：当投掷完 nn 枚骰子后，各个点数出现的次数。

注意，这里的点数指的是前 nn 枚骰子的点数和，而不是第 nn 枚骰子的点数，下文同理。

找出了最后一个阶段，那状态表示就简单了。

首先用数组的第一维来表示阶段，也就是投掷完了几枚骰子。
然后用第二维来表示投掷完这些骰子后，可能出现的点数。
数组的值就表示，该阶段各个点数出现的次数。
所以状态表示就是这样的：dp[i][j]dp[i][j] ，表示投掷完 ii 枚骰子后，点数 jj 的出现次数。

找出状态转移方程
找状态转移方程也就是找各个阶段之间的转化关系，同样我们还是只需分析最后一个阶段，分析它的状态是如何得到的。

最后一个阶段也就是投掷完 nn 枚骰子后的这个阶段，我们用 dp[n][j]dp[n][j] 来表示最后一个阶段点数 jj 出现的次数。

单单看第 nn 枚骰子，它的点数可能为 1 , 2, 3, ... , 61,2,3,...,6 ，因此投掷完 nn 枚骰子后点数 jj 出现的次数，可以由投掷完 n-1n−1 枚骰子后，对应点数 j-1, j-2, j-3, ... , j-6j−1,j−2,j−3,...,j−6 出现的次数之和转化过来。


for (第n枚骰子的点数 i = 1; i <= 6; i ++) {
    dp[n][j] += dp[n-1][j - i]
}
写成数学公式是这样的：

dp[n][j] = \sum_{i=1}^6 dp[n-1][j-i]
dp[n][j]= 
i=1
∑
6
​	
 dp[n−1][j−i]

nn 表示阶段，jj 表示投掷完 nn 枚骰子后的点数和，ii 表示第 nn 枚骰子会出现的六个点数。

边界处理
这里的边界处理很简单，只要我们把可以直接知道的状态初始化就好了。

我们可以直接知道的状态是啥，就是第一阶段的状态：投掷完 11 枚骰子后，它的可能点数分别为 1, 2, 3, ... , 61,2,3,...,6 ，并且每个点数出现的次数都是 11 .


for (int i = 1; i <= 6; i ++) {
    dp[1][i] = 1;
}
代码

class Solution {
public:
    vector<double> twoSum(int n) {
        int dp[15][70];
        memset(dp, 0, sizeof(dp));
        for (int i = 1; i <= 6; i ++) {
            dp[1][i] = 1;
        }
        for (int i = 2; i <= n; i ++) {
            for (int j = i; j <= 6*i; j ++) {
                for (int cur = 1; cur <= 6; cur ++) {
                    if (j - cur <= 0) {
                        break;
                    }
                    dp[i][j] += dp[i-1][j-cur];
                }
            }
        }
        int all = pow(6, n);
        vector<double> ret;
        for (int i = n; i <= 6 * n; i ++) {
            ret.push_back(dp[n][i] * 1.0 / all);
        }
        return ret;
    }
}; 
空间优化
我们知道，每个阶段的状态都只和它前一阶段的状态有关，因此我们不需要用额外的一维来保存所有阶段。

用一维数组来保存一个阶段的状态，然后对下一个阶段可能出现的点数 jj 从大到小遍历，实现一个阶段到下一阶段的转换。


1 / 13

优化代码

class Solution {
public:
    vector<double> twoSum(int n) {
        int dp[70];
        memset(dp, 0, sizeof(dp));
        for (int i = 1; i <= 6; i ++) {
            dp[i] = 1;
        }
        for (int i = 2; i <= n; i ++) {
            for (int j = 6*i; j >= i; j --) {
                dp[j] = 0;
                for (int cur = 1; cur <= 6; cur ++) {
                    if (j - cur < i-1) {
                        break;
                    }
                    dp[j] += dp[j-cur];
                }
            }
        }
        int all = pow(6, n);
        vector<double> ret;
        for (int i = n; i <= 6 * n; i ++) {
            ret.push_back(dp[i] * 1.0 / all);
        }
        return ret;
    }
};

```java
class Solution {
public:
    vector<double> twoSum(int n) {
        int dp[70];
        memset(dp, 0, sizeof(dp));
        for (int i = 1; i <= 6; i ++) {
            dp[i] = 1;
        }
        for (int i = 2; i <= n; i ++) {
            for (int j = 6*i; j >= i; j --) {
                dp[j] = 0;
                for (int cur = 1; cur <= 6; cur ++) {
                    if (j - cur < i-1) {
                        break;
                    }
                    dp[j] += dp[j-cur];
                }
            }
        }
        int all = pow(6, n);
        vector<double> ret;
        for (int i = n; i <= 6 * n; i ++) {
            ret.push_back(dp[i] * 1.0 / all);
        }
        return ret;
    }
};
```
---
