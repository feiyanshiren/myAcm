1869. 哪种连续子字符串更长

给你一个二进制字符串 s 。如果字符串中由 1 组成的 最长 连续子字符串 严格长于 由 0 组成的 最长 连续子字符串，返回 true ；否则，返回 false 。

    例如，s = "110100010" 中，由 1 组成的最长连续子字符串的长度是 2 ，由 0 组成的最长连续子字符串的长度是 3 。

注意，如果字符串中不存在 0 ，此时认为由 0 组成的最长连续子字符串的长度是 0 。字符串中不存在 1 的情况也适用此规则。

 

示例 1：

输入：s = "1101"
输出：true
解释：
由 1 组成的最长连续子字符串的长度是 2："1101"
由 0 组成的最长连续子字符串的长度是 1："1101"
由 1 组成的子字符串更长，故返回 true 。

示例 2：

输入：s = "111000"
输出：false
解释：
由 1 组成的最长连续子字符串的长度是 3："111000"
由 0 组成的最长连续子字符串的长度是 3："111000"
由 1 组成的子字符串不比由 0 组成的子字符串长，故返回 false 。

示例 3：

输入：s = "110100010"
输出：false
解释：
由 1 组成的最长连续子字符串的长度是 2："110100010"
由 0 组成的最长连续子字符串的长度是 3："110100010"
由 1 组成的子字符串不比由 0 组成的子字符串长，故返回 false 。

 

提示：

    1 <= s.length <= 100
    s[i] 不是 '0' 就是 '1'


解，
标记5个变量，使用循环判断,注意最后+,
```py
class Solution:
    def checkZeroOnes(self, s: str) -> bool:
        max0 = 0
        max1 = 0
        le0 = 0
        le1 = 0
        old = ""
        for i in s:
            if i == old:
                if i == "0":
                    le0 += 1
                else:
                    le1 += 1
            else:
                if i == "0":
                    max1 = max(max1, le1)
                    le1 = 0
                    le0 += 1
                else:
                    max0 = max(max0, le0)
                    le0 = 0
                    le1 += 1
            old = i
        max1 = max(max1, le1)
        max0 = max(max0, le0)
        return max1 > max0
```
---


1869. 哪种连续子字符串更长    --2

给你一个二进制字符串 s 。如果字符串中由 1 组成的 最长 连续子字符串 严格长于 由 0 组成的 最长 连续子字符串，返回 true ；否则，返回 false 。

    例如，s = "110100010" 中，由 1 组成的最长连续子字符串的长度是 2 ，由 0 组成的最长连续子字符串的长度是 3 。

注意，如果字符串中不存在 0 ，此时认为由 0 组成的最长连续子字符串的长度是 0 。字符串中不存在 1 的情况也适用此规则。

 

示例 1：

输入：s = "1101"
输出：true
解释：
由 1 组成的最长连续子字符串的长度是 2："1101"
由 0 组成的最长连续子字符串的长度是 1："1101"
由 1 组成的子字符串更长，故返回 true 。

示例 2：

输入：s = "111000"
输出：false
解释：
由 1 组成的最长连续子字符串的长度是 3："111000"
由 0 组成的最长连续子字符串的长度是 3："111000"
由 1 组成的子字符串不比由 0 组成的子字符串长，故返回 false 。

示例 3：

输入：s = "110100010"
输出：false
解释：
由 1 组成的最长连续子字符串的长度是 2："110100010"
由 0 组成的最长连续子字符串的长度是 3："110100010"
由 1 组成的子字符串不比由 0 组成的子字符串长，故返回 false 。

 

提示：

    1 <= s.length <= 100
    s[i] 不是 '0' 就是 '1'


解，
一行，拆分字符串，比较两个里面的长度
```py
class Solution:
    def checkZeroOnes(self, s: str) -> bool:
        return max([len(i) for i in s.split("0")]) > max([len(i) for i in s.split("1")])

```
---


1869. 哪种连续子字符串更长    --3

给你一个二进制字符串 s 。如果字符串中由 1 组成的 最长 连续子字符串 严格长于 由 0 组成的 最长 连续子字符串，返回 true ；否则，返回 false 。

    例如，s = "110100010" 中，由 1 组成的最长连续子字符串的长度是 2 ，由 0 组成的最长连续子字符串的长度是 3 。

注意，如果字符串中不存在 0 ，此时认为由 0 组成的最长连续子字符串的长度是 0 。字符串中不存在 1 的情况也适用此规则。

 

示例 1：

输入：s = "1101"
输出：true
解释：
由 1 组成的最长连续子字符串的长度是 2："1101"
由 0 组成的最长连续子字符串的长度是 1："1101"
由 1 组成的子字符串更长，故返回 true 。

示例 2：

输入：s = "111000"
输出：false
解释：
由 1 组成的最长连续子字符串的长度是 3："111000"
由 0 组成的最长连续子字符串的长度是 3："111000"
由 1 组成的子字符串不比由 0 组成的子字符串长，故返回 false 。

示例 3：

输入：s = "110100010"
输出：false
解释：
由 1 组成的最长连续子字符串的长度是 2："110100010"
由 0 组成的最长连续子字符串的长度是 3："110100010"
由 1 组成的子字符串不比由 0 组成的子字符串长，故返回 false 。

 

提示：

    1 <= s.length <= 100
    s[i] 不是 '0' 就是 '1'


解，
标记4个变量，使用循环判断,少了个变量判断，要快点？
```py
class Solution:
    def checkZeroOnes(self, s: str) -> bool:
        max0 = 0
        max1 = 0
        le0 = 0
        le1 = 0
        for i in s:
            if i == "0":
                le0 += 1
                le1 = 0
            else:
                le1 += 1
                le0 = 0
            max1 = max(max1, le1)
            max0 = max(max0, le0)
        return max1 > max0

```
---


1869. 哪种连续子字符串更长    --4

给你一个二进制字符串 s 。如果字符串中由 1 组成的 最长 连续子字符串 严格长于 由 0 组成的 最长 连续子字符串，返回 true ；否则，返回 false 。

    例如，s = "110100010" 中，由 1 组成的最长连续子字符串的长度是 2 ，由 0 组成的最长连续子字符串的长度是 3 。

注意，如果字符串中不存在 0 ，此时认为由 0 组成的最长连续子字符串的长度是 0 。字符串中不存在 1 的情况也适用此规则。

 

示例 1：

输入：s = "1101"
输出：true
解释：
由 1 组成的最长连续子字符串的长度是 2："1101"
由 0 组成的最长连续子字符串的长度是 1："1101"
由 1 组成的子字符串更长，故返回 true 。

示例 2：

输入：s = "111000"
输出：false
解释：
由 1 组成的最长连续子字符串的长度是 3："111000"
由 0 组成的最长连续子字符串的长度是 3："111000"
由 1 组成的子字符串不比由 0 组成的子字符串长，故返回 false 。

示例 3：

输入：s = "110100010"
输出：false
解释：
由 1 组成的最长连续子字符串的长度是 2："110100010"
由 0 组成的最长连续子字符串的长度是 3："110100010"
由 1 组成的子字符串不比由 0 组成的子字符串长，故返回 false 。

 

提示：

    1 <= s.length <= 100
    s[i] 不是 '0' 就是 '1'


解，
标记4个变量，使用循环判断,少了个变量判断，要快点？ go 语言版，100+
```go
func checkZeroOnes(s string) bool {
    max0 := 0
    max1 := 0
    le0 := 0
    le1 := 0
    for _, v := range s{
        if v == '0'{
            le0 += 1
            le1 = 0
        }else{
            le1 += 1
            le0 = 0
        }
        if max1 < le1{
            max1 = le1
        }
        if max0 < le0{
            max0 = le0
        }
    }
    return max1 > max0
}

```
---