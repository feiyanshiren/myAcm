1913. 两个数对之间的最大乘积差

两个数对 (a, b) 和 (c, d) 之间的 乘积差 定义为 (a * b) - (c * d) 。

    例如，(5, 6) 和 (2, 7) 之间的乘积差是 (5 * 6) - (2 * 7) = 16 。

给你一个整数数组 nums ，选出四个 不同的 下标 w、x、y 和 z ，使数对 (nums[w], nums[x]) 和 (nums[y], nums[z]) 之间的 乘积差 取到 最大值 。

返回以这种方式取得的乘积差中的 最大值 。

 

示例 1：

输入：nums = [5,6,2,7,4]
输出：34
解释：可以选出下标为 1 和 3 的元素构成第一个数对 (6, 7) 以及下标 2 和 4 构成第二个数对 (2, 4)
乘积差是 (6 * 7) - (2 * 4) = 34

示例 2：

输入：nums = [4,2,5,9,7,4,8]
输出：64
解释：可以选出下标为 3 和 6 的元素构成第一个数对 (9, 8) 以及下标 1 和 5 构成第二个数对 (2, 4)
乘积差是 (9 * 8) - (2 * 4) = 64

 

提示：

    4 <= nums.length <= 104
    1 <= nums[i] <= 104

解：
排序，然后计算
```py
class Solution:
    def maxProductDifference(self, nums: List[int]) -> int:
        nums.sort()
        return (nums[-1] * nums[-2]) - (nums[0] * nums[1])
```
---


1913. 两个数对之间的最大乘积差    --2

两个数对 (a, b) 和 (c, d) 之间的 乘积差 定义为 (a * b) - (c * d) 。

    例如，(5, 6) 和 (2, 7) 之间的乘积差是 (5 * 6) - (2 * 7) = 16 。

给你一个整数数组 nums ，选出四个 不同的 下标 w、x、y 和 z ，使数对 (nums[w], nums[x]) 和 (nums[y], nums[z]) 之间的 乘积差 取到 最大值 。

返回以这种方式取得的乘积差中的 最大值 。

 

示例 1：

输入：nums = [5,6,2,7,4]
输出：34
解释：可以选出下标为 1 和 3 的元素构成第一个数对 (6, 7) 以及下标 2 和 4 构成第二个数对 (2, 4)
乘积差是 (6 * 7) - (2 * 4) = 34

示例 2：

输入：nums = [4,2,5,9,7,4,8]
输出：64
解释：可以选出下标为 3 和 6 的元素构成第一个数对 (9, 8) 以及下标 1 和 5 构成第二个数对 (2, 4)
乘积差是 (9 * 8) - (2 * 4) = 64

 

提示：

    4 <= nums.length <= 104
    1 <= nums[i] <= 104

解：
不排序。一次遍历，找两个大的和两个小的，注意细节就好。94+
```py
class Solution:
    def maxProductDifference(self, nums: List[int]) -> int:
        min1 = 99999
        min2 = 99999
        max1 = 0
        max2 = 0
        for i in nums:
            if i < min1:
                min2 = min1
                min1 = i
            elif i < min2 and i >= min1:
                min2 = i
            if i > max1:
                max2 = max1
                max1 = i
            elif i > max2 and i <= max1:
                max2 = i
        return (max1 * max2) - (min1 * min2)
```
---


1913. 两个数对之间的最大乘积差    --3

两个数对 (a, b) 和 (c, d) 之间的 乘积差 定义为 (a * b) - (c * d) 。

    例如，(5, 6) 和 (2, 7) 之间的乘积差是 (5 * 6) - (2 * 7) = 16 。

给你一个整数数组 nums ，选出四个 不同的 下标 w、x、y 和 z ，使数对 (nums[w], nums[x]) 和 (nums[y], nums[z]) 之间的 乘积差 取到 最大值 。

返回以这种方式取得的乘积差中的 最大值 。

 

示例 1：

输入：nums = [5,6,2,7,4]
输出：34
解释：可以选出下标为 1 和 3 的元素构成第一个数对 (6, 7) 以及下标 2 和 4 构成第二个数对 (2, 4)
乘积差是 (6 * 7) - (2 * 4) = 34

示例 2：

输入：nums = [4,2,5,9,7,4,8]
输出：64
解释：可以选出下标为 3 和 6 的元素构成第一个数对 (9, 8) 以及下标 1 和 5 构成第二个数对 (2, 4)
乘积差是 (9 * 8) - (2 * 4) = 64

 

提示：

    4 <= nums.length <= 104
    1 <= nums[i] <= 104

解：
不排序。一次遍历，找两个大的和两个小的，注意细节就好。go语言版。94+
```go
func maxProductDifference(nums []int) int {
    min1 := 99999
    min2 := 99999
    max1 := 0
    max2 := 0
    for _, v := range nums{
        if v < min1{
            min2 = min1
            min1 = v
        }else if v < min2 && v >= min1{
            min2 = v
        }
        if v > max1{
            max2 = max1
            max1 = v
        }else if v > max2 && v <= max1{
            max2 = v
        }     
    }
    return (max1 * max2) - (min1 * min2)
}
```
---