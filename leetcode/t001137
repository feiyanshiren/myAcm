1137. 第 N 个泰波那契数

泰波那契序列 Tn 定义如下： 

T0 = 0, T1 = 1, T2 = 1, 且在 n >= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2

给你整数 n，请返回第 n 个泰波那契数 Tn 的值。

 

示例 1：

输入：n = 4
输出：4
解释：
T_3 = 0 + 1 + 1 = 2
T_4 = 1 + 1 + 2 = 4

示例 2：

输入：n = 25
输出：1389537

 

提示：

    0 <= n <= 37
    答案保证是一个 32 位整数，即 answer <= 2^31 - 1。

解：递归加缓存，不加缓存要超时
```py
from functools import lru_cache
class Solution:
    def tribonacci(self, n: int) -> int:
        @lru_cache(maxsize=37)
        def f(n):
            if n == 0:
                return 0
            elif n == 1:
                return 1
            elif n == 2:
                return 1
            else:
                return f(n - 1) + f(n - 2) + f(n - 3)
        return f(n)
```
---


1137. 第 N 个泰波那契数    --2

泰波那契序列 Tn 定义如下： 

T0 = 0, T1 = 1, T2 = 1, 且在 n >= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2

给你整数 n，请返回第 n 个泰波那契数 Tn 的值。

 

示例 1：

输入：n = 4
输出：4
解释：
T_3 = 0 + 1 + 1 = 2
T_4 = 1 + 1 + 2 = 4

示例 2：

输入：n = 25
输出：1389537

 

提示：

    0 <= n <= 37
    答案保证是一个 32 位整数，即 answer <= 2^31 - 1。

解：打表
```py
class Solution:
    def tribonacci(self, n: int) -> int:
        return {0: 0, 1: 1, 2: 1, 3: 2, 4: 4, 5: 7, 6: 13, 7: 24, 8: 44, 9: 81, 10: 149, 11: 274, 12: 504, 13: 927, 14: 1705, 15: 3136, 16: 5768, 17: 10609, 18: 19513, 19: 35890, 20: 66012, 21: 121415, 22: 223317, 23: 410744, 24: 755476, 25: 1389537, 26: 2555757, 27: 4700770, 28: 8646064, 29: 15902591, 30: 29249425, 31: 53798080, 32: 98950096, 33: 181997601, 34: 334745777, 35: 615693474, 36: 1132436852, 37: 2082876103}[n]
```
---


1137. 第 N 个泰波那契数    --3

泰波那契序列 Tn 定义如下： 

T0 = 0, T1 = 1, T2 = 1, 且在 n >= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2

给你整数 n，请返回第 n 个泰波那契数 Tn 的值。

 

示例 1：

输入：n = 4
输出：4
解释：
T_3 = 0 + 1 + 1 = 2
T_4 = 1 + 1 + 2 = 4

示例 2：

输入：n = 25
输出：1389537

 

提示：

    0 <= n <= 37
    答案保证是一个 32 位整数，即 answer <= 2^31 - 1。

解：递归再使用map保存优化，双百
```go
var m map[int] int

func tribonacci(n int) int {
    m = make(map[int] int)
    return f(n)

}

func f(n int) int {
    if n == 0{
        return 0
    }else if n == 1 || n == 2{
        return 1
    }else{
        k := m[n]
        if k == 0{
            k = f(n - 1) + f(n - 2) + f(n - 3)
            m[n] = k
        }
        return k
    }
}
```
---
