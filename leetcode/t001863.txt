1863. 找出所有子集的异或总和再求和

一个数组的 异或总和 定义为数组中所有元素按位 XOR 的结果；如果数组为 空 ，则异或总和为 0 。

    例如，数组 [2,5,6] 的 异或总和 为 2 XOR 5 XOR 6 = 1 。

给你一个数组 nums ，请你求出 nums 中每个 子集 的 异或总和 ，计算并返回这些值相加之 和 。

注意：在本题中，元素 相同 的不同子集应 多次 计数。

数组 a 是数组 b 的一个 子集 的前提条件是：从 b 删除几个（也可能不删除）元素能够得到 a 。

 

示例 1：

输入：nums = [1,3]
输出：6
解释：[1,3] 共有 4 个子集：
- 空子集的异或总和是 0 。
- [1] 的异或总和为 1 。
- [3] 的异或总和为 3 。
- [1,3] 的异或总和为 1 XOR 3 = 2 。
0 + 1 + 3 + 2 = 6

示例 2：

输入：nums = [5,1,6]
输出：28
解释：[5,1,6] 共有 8 个子集：
- 空子集的异或总和是 0 。
- [5] 的异或总和为 5 。
- [1] 的异或总和为 1 。
- [6] 的异或总和为 6 。
- [5,1] 的异或总和为 5 XOR 1 = 4 。
- [5,6] 的异或总和为 5 XOR 6 = 3 。
- [1,6] 的异或总和为 1 XOR 6 = 7 。
- [5,1,6] 的异或总和为 5 XOR 1 XOR 6 = 2 。
0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28

示例 3：

输入：nums = [3,4,5,6,7,8]
输出：480
解释：每个子集的全部异或总和值之和为 480 。

 

提示：

    1 <= nums.length <= 12
    1 <= nums[i] <= 20


解：
递归，找出所有子集，要超时

```py
class Solution:
    def subsetXORSum(self, nums: List[int]) -> int:
        self.zi = []
        map_de_to = {i: nums[i] for i in range(len(nums))}

        def f(map_de):
            if not map_de:
                return
            else:
                if map_de not in self.zi:
                    self.zi.append(map_de)
                for k, v in map_de.items():
                    f({k2: v2 for k2, v2 in map_de.items() if k2 != k})

        f(map_de_to)
        return sum([reduce(lambda x, y: x ^ y, list(i.values())) for i in self.zi])
```
---


1863. 找出所有子集的异或总和再求和    --2

一个数组的 异或总和 定义为数组中所有元素按位 XOR 的结果；如果数组为 空 ，则异或总和为 0 。

    例如，数组 [2,5,6] 的 异或总和 为 2 XOR 5 XOR 6 = 1 。

给你一个数组 nums ，请你求出 nums 中每个 子集 的 异或总和 ，计算并返回这些值相加之 和 。

注意：在本题中，元素 相同 的不同子集应 多次 计数。

数组 a 是数组 b 的一个 子集 的前提条件是：从 b 删除几个（也可能不删除）元素能够得到 a 。

 

示例 1：

输入：nums = [1,3]
输出：6
解释：[1,3] 共有 4 个子集：
- 空子集的异或总和是 0 。
- [1] 的异或总和为 1 。
- [3] 的异或总和为 3 。
- [1,3] 的异或总和为 1 XOR 3 = 2 。
0 + 1 + 3 + 2 = 6

示例 2：

输入：nums = [5,1,6]
输出：28
解释：[5,1,6] 共有 8 个子集：
- 空子集的异或总和是 0 。
- [5] 的异或总和为 5 。
- [1] 的异或总和为 1 。
- [6] 的异或总和为 6 。
- [5,1] 的异或总和为 5 XOR 1 = 4 。
- [5,6] 的异或总和为 5 XOR 6 = 3 。
- [1,6] 的异或总和为 1 XOR 6 = 7 。
- [5,1,6] 的异或总和为 5 XOR 1 XOR 6 = 2 。
0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28

示例 3：

输入：nums = [3,4,5,6,7,8]
输出：480
解释：每个子集的全部异或总和值之和为 480 。

 

提示：

    1 <= nums.length <= 12
    1 <= nums[i] <= 20


解：  98+
数学
假设数组元素个数为 nnn，那么第一种情况下，所有子集异或总和中该位均为 000；第二种情况下，所有子集异或总和中该位为 000 的个数与为 111 的个数相等，均为 2n−12^{n-1}2n−1。

提示 222 解释

首先，一个子集的异或总和中某位为 000 当且仅当子集内该位为 111 的元素数量为偶数（包括 000），某位为 111 当且仅当子集内该位为 111 的元素数量为奇数。那么第一种情况时显然所有子集的异或总和中该位都为 000。

其次，假设数组内某一位为 111 的元素个数为 mmm，那么它的子集里面包含 kkk 个 111 的数量为（k≤m≤nk \le m \le nk≤m≤n）：

思路与算法

根据 提示 222，我们用 res\textit{res}res 来维护数组全体元素的按位或，使得 res\textit{res}res 的某一位为 111 当且仅当数组中存在该位为 111 的元素。

那么，对于 res\textit{res}res 中为 111 的任何一位，其对于结果的贡献均为该位对应的值乘上异或总和为 111 的子集数量 2n−12^{n-1}2n−1；对于为 000 的任何一位，乘上 2n−12^{n-1}2n−1 也不会对结果产生影响。因此我们可以直接将 res\textit{res}res 算术左移 n−1n - 1n−1 位作为结果返回。


```py    
class Solution:
    def subsetXORSum(self, nums: List[int]) -> int:
        r = 0
        n = len(nums)
        for num in nums:
            r |= num
        return r << (n - 1)

```
---



1863. 找出所有子集的异或总和再求和    --3

一个数组的 异或总和 定义为数组中所有元素按位 XOR 的结果；如果数组为 空 ，则异或总和为 0 。

    例如，数组 [2,5,6] 的 异或总和 为 2 XOR 5 XOR 6 = 1 。

给你一个数组 nums ，请你求出 nums 中每个 子集 的 异或总和 ，计算并返回这些值相加之 和 。

注意：在本题中，元素 相同 的不同子集应 多次 计数。

数组 a 是数组 b 的一个 子集 的前提条件是：从 b 删除几个（也可能不删除）元素能够得到 a 。

 

示例 1：

输入：nums = [1,3]
输出：6
解释：[1,3] 共有 4 个子集：
- 空子集的异或总和是 0 。
- [1] 的异或总和为 1 。
- [3] 的异或总和为 3 。
- [1,3] 的异或总和为 1 XOR 3 = 2 。
0 + 1 + 3 + 2 = 6

示例 2：

输入：nums = [5,1,6]
输出：28
解释：[5,1,6] 共有 8 个子集：
- 空子集的异或总和是 0 。
- [5] 的异或总和为 5 。
- [1] 的异或总和为 1 。
- [6] 的异或总和为 6 。
- [5,1] 的异或总和为 5 XOR 1 = 4 。
- [5,6] 的异或总和为 5 XOR 6 = 3 。
- [1,6] 的异或总和为 1 XOR 6 = 7 。
- [5,1,6] 的异或总和为 5 XOR 1 XOR 6 = 2 。
0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28

示例 3：

输入：nums = [3,4,5,6,7,8]
输出：480
解释：每个子集的全部异或总和值之和为 480 。

 

提示：

    1 <= nums.length <= 12
    1 <= nums[i] <= 20


解：
数学 go 100+



```go
func subsetXORSum(nums []int) int {
    r := 0
    n := len(nums)
    for _, v := range nums{
        r |= v
    }
    return r << (n - 1)
}

```
---