938. 二叉搜索树的范围和

给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。

二叉搜索树保证具有唯一的值。



示例 1：

输入：root = [10,5,15,3,7,null,18], L = 7, R = 15
输出：32

示例 2：

输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10
输出：23



提示：

    树中的结点数量最多为 10000 个。
    最终的答案保证小于 2^31。

解：
题意有点麻烦，说的是小于L的就搜索右边，大于R的就搜索左边



```py
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:
        self.h = 0
        def d(node):
            if not node:
                return
            if node.val < L:
                d(node.right)
            elif node.val > R:
                d(node.left)
            elif node.val >= L and node.val <= R:
                self.h += node.val
                d(node.left)
                d(node.right)
        d(root)
        return self.h
```
---


938. 二叉搜索树的范围和    --2

给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。

二叉搜索树保证具有唯一的值。



示例 1：

输入：root = [10,5,15,3,7,null,18], L = 7, R = 15
输出：32

示例 2：

输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10
输出：23



提示：

    树中的结点数量最多为 10000 个。
    最终的答案保证小于 2^31。

解：
题意有点麻烦，说的是小于L的就搜索右边，大于R的就搜索左边
精简一下，取消一些判断



```py
class Solution(object):
    def rangeSumBST(self, root, L, R):
        def dfs(node):
            if node:
                if L <= node.val <= R:
                    self.ans += node.val
                if L < node.val:
                    dfs(node.left)
                if node.val < R:
                    dfs(node.right)

        self.ans = 0
        dfs(root)
        return self.ans


```
---


938. 二叉搜索树的范围和    --4

给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。

二叉搜索树保证具有唯一的值。



示例 1：

输入：root = [10,5,15,3,7,null,18], L = 7, R = 15
输出：32

示例 2：

输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10
输出：23



提示：

    树中的结点数量最多为 10000 个。
    最终的答案保证小于 2^31。

解：
题意有点麻烦，说的是小于L的就搜索右边，大于R的就搜索左边
使用迭代



```py
class Solution(object):
    def rangeSumBST(self, root, L, R):
        ans = 0
        stack = [root]
        while stack:
            node = stack.pop()
            if node:
                if L <= node.val <= R:
                    ans += node.val
                if L < node.val:
                    stack.append(node.left)
                if node.val < R:
                    stack.append(node.right)
        return ans




```
---