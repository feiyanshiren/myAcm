1175. 质数排列

请你帮忙给从 1 到 n 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。

让我们一起来回顾一下「质数」：质数一定是大于 1 的，并且不能用两个小于它的正整数的乘积来表示。

由于答案可能会很大，所以请你返回答案 模 mod 10^9 + 7 之后的结果即可。

 

示例 1：

输入：n = 5
输出：12
解释：举个例子，[1,2,5,4,3] 是一个有效的排列，但 [5,2,3,4,1] 不是，因为在第二种情况里质数 5 被错误地放在索引为 1 的位置上。

示例 2：

输入：n = 100
输出：682289015

 

提示：

    1 <= n <= 100

解：
质数个数的全排列 * 非质数个数的全排列 就是答案。 例如：[1,2,5,4,3]，质数[3,5] 个数是 2，非质数[1,2,4]个数是3，答案就是 2！* 3！= 2 * 1 * 3 * 2 * 1 = 12

```py
class Solution:
    def numPrimeArrangements(self, n: int) -> int:
        def isP(num):
            i = 2
            while i ** 2 <= num:
                if num % i == 0:
                    return 0
                i += 1
            return 1
        
        c1 = 0
        s1 = 1

        c2 = 1
        s2 = 1

        for i in range(2, n + 1):
            if isP(i):
                c1 += 1
                s1 *= c1
            else:
                c2 += 1
                s2 *= c2
        return (s1 * s2) % (10**9 + 7)
```
---


1175. 质数排列    --2

请你帮忙给从 1 到 n 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。

让我们一起来回顾一下「质数」：质数一定是大于 1 的，并且不能用两个小于它的正整数的乘积来表示。

由于答案可能会很大，所以请你返回答案 模 mod 10^9 + 7 之后的结果即可。

 

示例 1：

输入：n = 5
输出：12
解释：举个例子，[1,2,5,4,3] 是一个有效的排列，但 [5,2,3,4,1] 不是，因为在第二种情况里质数 5 被错误地放在索引为 1 的位置上。

示例 2：

输入：n = 100
输出：682289015

 

提示：

    1 <= n <= 100

解：
打表

```py
class Solution:
    def numPrimeArrangements(self, n: int) -> int:
        ans = [1, 1, 1, 2, 4, 12, 36, 144, 576, 2880, 17280, 86400, 604800, 3628800, 29030400, 261273600, 612735986, 289151874, 180670593, 445364737, 344376809, 476898489, 676578804, 89209194, 338137903, 410206413, 973508979, 523161503, 940068494, 400684877, 13697484, 150672324, 164118783, 610613205, 44103617, 58486801, 462170018, 546040181, 197044608, 320204381, 965722612, 554393872, 77422176, 83910457, 517313696, 36724464, 175182841, 627742601, 715505693, 327193394, 451768713, 263673556, 755921509, 94744060, 600274259, 410695940, 427837488, 541336889, 736149184, 514536044, 125049738, 250895270, 39391803, 772631128, 541031643, 428487046, 567378068, 780183222, 228977612, 448880523, 892906519, 858130261, 622773264, 78238453, 146637981, 918450925, 514800525, 828829204, 243264299, 351814543, 405243354, 909357725, 561463122, 913651722, 732754657, 430788419, 139670208, 938893256, 28061213, 673469112, 448961084, 80392418, 466684389, 201222617, 85583092, 76399490, 500763245, 519081041, 892915734, 75763854, 682289015]
        return ans[n]
```
---



1175. 质数排列    --3

请你帮忙给从 1 到 n 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。

让我们一起来回顾一下「质数」：质数一定是大于 1 的，并且不能用两个小于它的正整数的乘积来表示。

由于答案可能会很大，所以请你返回答案 模 mod 10^9 + 7 之后的结果即可。

 

示例 1：

输入：n = 5
输出：12
解释：举个例子，[1,2,5,4,3] 是一个有效的排列，但 [5,2,3,4,1] 不是，因为在第二种情况里质数 5 被错误地放在索引为 1 的位置上。

示例 2：

输入：n = 100
输出：682289015

 

提示：

    1 <= n <= 100

解：
(a * b) % p = (a % p * b % p) % p
go,双百 注意求全排列中间数据太大了，需要中间就求模

```go
func numPrimeArrangements(n int) int {
    var c1, s1, c2, s2 int64
    c1 = 0
    s1 = 1
    c2 = 1
    s2 = 1

    for i := 2; i < n + 1; i++{
        if isP(i) == 1{
            c1 += 1
            s1 *= c1
            s1 %= 1000000007

        }else{
            c2 += 1
            s2 *= c2
            s2 %= 1000000007
        }
    }
    return int(s1 * s2) % 1000000007
}

func isP(n int) int {
    i := 2
    for i * i <= n{
        if n % i == 0{
            return 0
        }
        i += 1
    }
    return 1
}
```
---
